---
phase: 02-code-generation
plan: 05
type: execute
wave: 3
depends_on:
  - 02-04
files_modified:
  - frontend/app/page.tsx
  - frontend/app/components/GeneratingView.tsx
  - frontend/app/components/FramePreview.tsx
  - frontend/lib/api.ts
  - frontend/lib/types.ts
autonomous: true
requirements:
  - CODE-01
must_haves:
  truths:
    - After import success, generating state shows with quirky progress messages
    - On generation complete, success state shows "Your prototype is ready" + thumbnail
    - Regenerate button appears after first generation, triggers regenerate
    - Errors show friendly message with retry option
  artifacts:
    - path: frontend/app/components/GeneratingView.tsx
      provides: Skeleton with quirky progress storytelling
      contains: "GeneratingView"
    - path: frontend/app/page.tsx
      provides: generating ViewMode, auto-trigger flow
      contains: "generating"
    - path: frontend/lib/api.ts
      provides: generateCode, getPrototypeSession
      contains: "generateCode|getPrototypeSession"
  key_links:
    - from: frontend/app/page.tsx
      to: frontend/lib/api.ts
      via: generateCode() after import success
      pattern: "generateCode"
    - from: frontend/app/components/FramePreview.tsx
      to: frontend/lib/api.ts
      via: Regenerate button → generateCode
      pattern: "generateCode|Regenerate"

---

<objective>
Frontend: generating state with quirky progress storytelling, auto-trigger code gen after import, success state "Your prototype is ready", Regenerate button. Error handling with retry.

Purpose: User experience for Phase 2 — no manual trigger, playful loading, clear success, regenerate for testing.
Output: GeneratingView, page.tsx flow, FramePreview updates, api.ts functions.
</objective>

<execution_context>
@/Users/shubham/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shubham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-code-generation/02-CONTEXT.md
@.planning/phases/02-code-generation/02-RESEARCH.md
@frontend/app/page.tsx
@frontend/app/components/FramePreview.tsx
@frontend/app/components/ImportingView.tsx
@frontend/lib/api.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: API functions and types</name>
  <files>frontend/lib/api.ts, frontend/lib/types.ts</files>
  <action>
    Add generateCode(importResult: FigmaImportResponse): Promise<CodeGenerateResponse> — POST /api/code/generate with credentials: include, body: { design_context, thumbnail_url, frame_name, frame_width, frame_height, file_key, node_id } from importResult. Throw with friendly message + (Ref: BP-XXX) on error. Use X-Request-Id. Blocks 10-30s until generation completes.
    Add getPrototypeSession(): Promise<PrototypeSession | null> — GET /api/code/session with credentials: include. Returns current session or null (404). Used for session restore on page refresh.
    For Regenerate: same generateCode but with existing session — we need to pass design_context etc. The session stores design_context. So Regenerate could POST with session_id to mean "regenerate for this session" — backend would load design_context from DB. Add CodeRegenerateRequest(session_id: str) and endpoint POST /api/code/regenerate? Or we could pass the same import result. When user clicks Regenerate, we still have importResult in state (we're in success view). So we can call generateCode(importResult) again. Same flow. No new endpoint for Regenerate — just call generateCode again with same data. Good.
    Ensure types.ts has CodeGenerateRequest, CodeGenerateResponse, PrototypeSession from 02-01. Add file_key, node_id to FigmaImportResponse type when backend adds them.
  </action>
  <verify>generateCode compiles. Types match backend.</verify>
  <done>API functions for code generation.</done>
</task>

<task type="auto">
  <name>Task 2: GeneratingView component</name>
  <files>frontend/app/components/GeneratingView.tsx</files>
  <action>
    Create GeneratingView.tsx. Skeleton layout similar to ImportingView — preview area placeholder. Quirky progress messages (playful tone per CONTEXT.md): e.g. "Reading the design tea leaves...", "Translating pixels to React...", "Almost there, your prototype is taking shape...". Rotate messages every 3-4 seconds. Use design tokens: bg-sand-light, text-charcoal, rounded-card. No generic "Loading...".
  </action>
  <verify>GeneratingView renders skeleton and cycles through messages.</verify>
  <done>GeneratingView with quirky storytelling.</done>
</task>

<task type="auto">
  <name>Task 3: Page flow — generating state and auto-trigger</name>
  <files>frontend/app/page.tsx</files>
  <action>
    Add ViewMode "generating". On import success (handleImportClick): instead of setViewMode("success"), setViewMode("generating") and call generateCode(importResult). While generating: show GeneratingView. When generateCode resolves: if status==='ready', setViewMode("success"), keep importResult. If status==='error', setViewMode("error"), setImportError with friendly message + error_code, offer retry. On retry: setViewMode("generating"), call generateCode(importResult) again.
    On mount: call getPrototypeSession(). If session exists with status='ready', show success state using session.thumbnail_url, session.frame_name, etc. (session restore on page refresh).
    Store sessionId from response for potential future use (Phase 3).
  </action>
  <verify>Import → generating → success. Import → generating → error shows retry.</verify>
  <done>Auto-trigger flow and generating state work.</done>
</task>

<task type="auto">
  <name>Task 4: FramePreview success state and Regenerate</name>
  <files>frontend/app/components/FramePreview.tsx</files>
  <action>
    Change "Code generation coming in Phase 2" to "Your prototype is ready". Add Regenerate button (only visible after first generation — we're in success view so it's always "after generation"). Add onRegenerate?: () => void prop. When clicked, call onRegenerate. Parent (page.tsx) will set viewMode to "generating" and call generateCode(importResult) again. On success, return to success view. On error, show error with retry.
    Regenerate button: text "Regenerate", style consistent with "Import another frame" (text-xs, hover:underline). Place in header area.
  </action>
  <verify>FramePreview shows "Your prototype is ready". Regenerate triggers parent callback.</verify>
  <done>Success copy and Regenerate button in place.</done>
</task>

<task type="auto">
  <name>Task 5: Error display</name>
  <files>frontend/app/page.tsx</files>
  <action>
    On generation error: show "We're having trouble generating your prototype. Please try again. (Ref: BP-XXXXXX)". Include error_code from response. "Try again" button triggers generateCode again (same as retry). Per AGENTS.md: never show raw errors, provider names, stack traces.
  </action>
  <verify>Generation failure shows friendly message + ref code.</verify>
  <done>Errors follow AGENTS.md display rules.</done>
</task>

</tasks>

<verification>
- Import success → generating → success
- GeneratingView shows quirky messages
- Success: "Your prototype is ready" + thumbnail
- Regenerate works
- Errors friendly with retry
</verification>

<success_criteria>
- Full Phase 2 flow: import → auto-generate → success
- Regenerate for testing
- Quirky progress, friendly errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-code-generation/02-05-SUMMARY.md`
</output>
