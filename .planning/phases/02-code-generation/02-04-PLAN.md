---
phase: 02-code-generation
plan: 04
type: execute
wave: 2
depends_on:
  - 02-01
  - 02-02
  - 02-03
files_modified:
  - backend/app/api/figma.py
  - backend/app/models.py
  - backend/app/api/codegen.py
  - backend/app/prompts.py
  - backend/app/main.py
  - backend/requirements.txt
autonomous: true
requirements:
  - CODE-01
must_haves:
  truths:
    - POST /api/code/generate accepts design context, returns session_id + status
    - Code generation uses vision LLM with thumbnail + transformed context
    - Generated code is validated (JSX parse) and stored in prototype_sessions
    - Auto-retry once on failure; friendly error with manual retry option
  artifacts:
    - path: backend/app/api/codegen.py
      provides: POST /api/code/generate
      contains: "generate|code"
    - path: backend/app/prompts.py
      provides: build_design_to_code_prompt
      contains: "design_to_code|build_design"
  key_links:
    - from: backend/app/api/codegen.py
      to: backend/app/figma_context.py
      via: transform_design_context
      pattern: "transform_design_context"
    - from: backend/app/api/codegen.py
      to: backend/app/llm.py
      via: call_llm_vision
      pattern: "call_llm_vision"
    - from: backend/app/api/codegen.py
      to: backend/app/db.py
      via: create_prototype_session, update_prototype_session
      pattern: "prototype_session"

---

<objective>
Code generation endpoint: receive design context from frontend, transform, call vision LLM, validate JSX, store in DB. Auto-retry once on failure.

Purpose: End-to-end backend flow for design-to-code. Frontend triggers after import; backend produces and persists React code.
Output: POST /api/code/generate, design-to-code prompt, JSX validation, session storage.
</objective>

<execution_context>
@/Users/shubham/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shubham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-code-generation/02-CONTEXT.md
@.planning/phases/02-code-generation/02-RESEARCH.md
@backend/app/api/figma.py
@backend/app/llm.py
@backend/app/db.py
@backend/app/figma_context.py
@backend/app/prompts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Figma import response and CodeGenerateRequest</name>
  <files>backend/app/api/figma.py, backend/app/models.py</files>
  <action>
    Add to FigmaImportResponse: file_key: str | None, node_id: str | None (for Figma API calls: thumbnail fetch, SVG export). In figma.py import handler, set file_key and node_id from parse_figma_url result.
    Update CodeGenerateRequest (from 02-01): add file_key: str | None, node_id: str | None. Frontend will pass these from import result.
    Update frontend types in 02-05 — this plan only touches backend.
  </action>
  <verify>FigmaImportResponse includes file_key, node_id. Import returns them.</verify>
  <done>file_key and node_id available for code gen.</done>
</task>

<task type="auto">
  <name>Task 2: Design-to-code prompt</name>
  <files>backend/app/prompts.py</files>
  <action>
    Add build_design_to_code_prompt(transformed_context: dict) -> str.
    Prompt structure (per 02-RESEARCH.md): Role (design-to-code expert), Constraints (Tailwind only, functional components, no lorem ipsum, preserve exact text, inline SVG for icons, placeholder.com for images if needed), Output format (single React component, default export, valid JSX).
    Include transformed_context as JSON in the prompt. Mark prompt text as # TODO: Replace with founder-authored prompt — implement wiring only.
    Return string for use in call_llm_vision.
  </action>
  <verify>build_design_to_code_prompt(transformed_context) returns non-empty string containing context.</verify>
  <done>Design-to-code prompt function exists.</done>
</task>

<task type="auto">
  <name>Task 3: Code generation endpoint</name>
  <files>backend/app/api/codegen.py, backend/app/main.py</files>
  <action>
    Create backend/app/api/codegen.py. POST /api/code/generate: accept CodeGenerateRequest (design_context, thumbnail_url, frame_name, frame_width, frame_height, file_key, node_id). Read session_id from bp_session cookie. If no session: create one (uuid) or return 401 if Figma tokens required — actually use same pattern as figma import: get tokens via session_id, if no tokens return 401.
    Flow: 1) Get session_id from cookie (create if missing, same as OAuth callback). 2) Get Figma tokens for thumbnail/SVG fetch. 3) create_prototype_session with status='generating'. 4) transform_design_context(raw). 5) Fetch thumbnail URL via httpx → base64. 6) Optionally fetch SVG for icon nodes (batch GET /v1/images/:file_key?ids=id1,id2&format=svg) — add to transformed context or pass to prompt. 7) Build prompt, call call_llm_vision(messages, image_base64). 8) strip_code_fences on response. 9) Validate JSX with esbuild-py (transform with loader tsx). 10) On valid: update_prototype_session with generated_code, status='ready'. 11) On invalid: retry once (full flow), then update status='error', error_code. 12) Return CodeGenerateResponse(session_id, status, error_code).
    Add esbuild-py to requirements.txt. Use try/except for esbuild transform; on exception consider invalid.
    Add GET /api/code/session: returns current PrototypeSession for bp_session cookie, or 404 if none. Used for session restore on page refresh.
    Register router: app.include_router(codegen.router) in main.py.
    Use generate_error_code() for all errors.

    **Logging** (import `from app.config import log, generate_error_code`):
    - Pipeline entry: `log("INFO", "code generation started", session_id=..., frame_name=..., has_thumbnail=bool(thumbnail_url))`
    - Transform complete: `log("INFO", "design context transformed", session_id=..., tree_nodes=..., icon_count=...)`
    - Thumbnail fetch: `log("INFO", "thumbnail fetched for vision", session_id=..., image_size_bytes=...)` or `log("WARN", "thumbnail fetch failed", session_id=..., error=str(e))`
    - SVG export: `log("INFO", "icon svg export completed", session_id=..., icon_count=..., fetched=...)` or `log("WARN", "icon svg export failed", session_id=..., error=str(e))`
    - JSX validation pass: `log("INFO", "jsx validation passed", session_id=..., code_length=...)`
    - JSX validation fail: `log("WARN", "jsx validation failed", session_id=..., error=str(e)[:200])`
    - Retry: `log("WARN", "code generation retry", session_id=..., attempt=2, reason=...)`
    - Pipeline success: `log("INFO", "code generation completed", session_id=..., duration_ms=..., code_length=...)`
    - Pipeline failure: `log("ERROR", "code generation failed", session_id=..., error_code=..., error=str(e))`
    - DB write failure: `log("ERROR", "db write failed", session_id=..., operation="update_prototype_session", error=str(e), error_code=...)`
    - GET session: `log("INFO", "session retrieved", session_id=..., status=...)` or `log("INFO", "session not found", session_id=...)`
  </action>
  <verify>POST /api/code/generate with valid body and session returns 200 with session_id and status. GET /api/code/session returns session when exists. Invalid/missing session returns 401. All log points visible in console output.</verify>
  <done>Code generation endpoint works end-to-end with comprehensive structured logging.</done>
</task>

<task type="auto">
  <name>Task 4: Figma SVG export for icons</name>
  <files>backend/app/api/codegen.py</files>
  <action>
    In codegen flow: from transformed context tree, collect node IDs where type is VECTOR or BOOLEAN_OPERATION (icon nodes). If file_key and node_ids non-empty: call GET https://api.figma.com/v1/images/{file_key}?ids={comma-separated}&format=svg with Bearer token. Parse response.images, fetch each SVG URL via httpx, store SVG content keyed by node_id. Pass to prompt as "icons": { "node_id": "<svg>...</svg>" } so LLM can embed inline. If fetch fails, omit icons (LLM uses placeholders).
  </action>
  <verify>Frame with VECTOR nodes produces icon SVGs in context when file_key available.</verify>
  <done>Icons exported as inline SVG when feasible.</done>
</task>

</tasks>

<verification>
- POST /api/code/generate returns session_id + status
- Code stored in prototype_sessions on success
- Auto-retry once on validation failure
- JSX validation via esbuild-py
- Figma SVG export for icons
</verification>

<success_criteria>
- Code generation endpoint complete
- Design-to-code pipeline: transform → vision LLM → validate → store
</success_criteria>

<output>
After completion, create `.planning/phases/02-code-generation/02-04-SUMMARY.md`
</output>
