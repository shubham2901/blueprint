---
phase: 02-code-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - PLAN.md
  - backend/app/models.py
  - backend/app/db.py
  - frontend/lib/types.ts
autonomous: true
requirements:
  - CODE-01
must_haves:
  truths:
    - prototype_sessions table exists in Supabase with required columns
    - Backend can create, update, and fetch prototype sessions
    - Frontend has TypeScript types for code generation request/response
  artifacts:
    - path: PLAN.md
      provides: prototype_sessions table schema
      contains: "prototype_sessions"
    - path: backend/app/models.py
      provides: CodeGenerateRequest, CodeGenerateResponse, PrototypeSession models
      contains: "CodeGenerate|PrototypeSession"
    - path: backend/app/db.py
      provides: create_prototype_session, update_prototype_session, get_prototype_session
      contains: "prototype_session"
    - path: frontend/lib/types.ts
      provides: CodeGenerateRequest, CodeGenerateResponse, PrototypeSession types
      contains: "CodeGenerate|PrototypeSession"
  key_links:
    - from: backend/app/db.py
      to: prototype_sessions table
      via: Supabase client
      pattern: "prototype_sessions"
---

<objective>
Create prototype_sessions table and Pydantic/TypeScript models for code generation. Enables storing generated React code and session metadata.

Purpose: Foundation for code storage — Phase 2 stores generated code in DB immediately after LLM generation.
Output: DB migration SQL, models.py additions, db.py CRUD functions, types.ts mirrors.
</objective>

<execution_context>
@/Users/shubham/.claude/get-shit-done/workflows/execute-plan.md
@/Users/shubham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-code-generation/02-CONTEXT.md
@.planning/phases/02-code-generation/02-RESEARCH.md
@backend/app/models.py
@backend/app/db.py
@frontend/lib/types.ts
@PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB schema and PLAN.md update</name>
  <files>PLAN.md</files>
  <action>
    Add prototype_sessions table to PLAN.md Part 5 (Database Schema). Schema:
    - id UUID PRIMARY KEY DEFAULT gen_random_uuid()
    - session_id TEXT NOT NULL (from bp_session cookie — same as figma_tokens)
    - design_context JSONB NOT NULL (raw or transformed Figma context)
    - generated_code TEXT (nullable until generation completes)
    - thumbnail_url TEXT (Figma PNG URL — may expire)
    - frame_name TEXT, frame_width INTEGER, frame_height INTEGER
    - status TEXT DEFAULT 'pending' ('pending' | 'generating' | 'ready' | 'error')
    - error_code TEXT (nullable, for error state)
    - created_at TIMESTAMPTZ DEFAULT now(), updated_at TIMESTAMPTZ DEFAULT now()
    Add UNIQUE(session_id) or use session_id as lookup key — one active session per cookie. Per CONTEXT.md: Regenerate overwrites previous code (V1). Use upsert by session_id.
    Run the SQL in Supabase SQL editor (no migration tool in V0 per AGENTS.md).
  </action>
  <verify>Table prototype_sessions exists in Supabase. Columns match schema.</verify>
  <done>prototype_sessions table created; PLAN.md Part 5 updated.</done>
</task>

<task type="auto">
  <name>Task 2: Pydantic models and db.py CRUD</name>
  <files>backend/app/models.py, backend/app/db.py</files>
  <action>
    In models.py add:
    - CodeGenerateRequest(design_context: dict, thumbnail_url: str | None, frame_name: str | None, frame_width: int | None, frame_height: int | None)
    - CodeGenerateResponse(session_id: str, status: str, error_code: str | None = None) — status: 'ready' | 'error'
    - PrototypeSession(id: str, session_id: str, design_context: dict, generated_code: str | None, thumbnail_url: str | None, frame_name: str | None, frame_width: int | None, frame_height: int | None, status: str, error_code: str | None, created_at: str, updated_at: str)
    In db.py add:
    - create_prototype_session(session_id: str, design_context: dict, thumbnail_url: str | None, frame_name: str | None, frame_width: int | None, frame_height: int | None) -> str — creates row with status='pending', returns id
    - update_prototype_session(session_id: str, generated_code: str | None = None, status: str | None = None, error_code: str | None = None) -> bool — upserts by session_id (Regenerate overwrites)
    - get_prototype_session(session_id: str) -> dict | None — returns row or None
    Use get_supabase() singleton. Log per AGENTS.md on write/read failure. Use generate_error_code() for error_code.
  </action>
  <verify>from app.db import create_prototype_session, update_prototype_session, get_prototype_session — no import errors. Call create then get — returns matching data.</verify>
  <done>Models and CRUD functions exist. DB operations work.</done>
</task>

<task type="auto">
  <name>Task 3: TypeScript types</name>
  <files>frontend/lib/types.ts</files>
  <action>
    Add types mirroring models.py:
    - CodeGenerateRequest: design_context, thumbnail_url?, frame_name?, frame_width?, frame_height?
    - CodeGenerateResponse: session_id, status ('ready' | 'error'), error_code?
    - PrototypeSession: id, session_id, design_context, generated_code?, thumbnail_url?, frame_name?, frame_width?, frame_height?, status, error_code?, created_at, updated_at
    Place near other API types. Export for use in api.ts.
  </action>
  <verify>Types compile. No duplicate exports.</verify>
  <done>TypeScript types mirror backend models.</done>
</task>

</tasks>

<verification>
- prototype_sessions table exists with correct columns
- create_prototype_session, update_prototype_session, get_prototype_session work
- Pydantic models validate
- TypeScript types match
</verification>

<success_criteria>
- DB schema and CRUD ready for code generation endpoint
- Models and types in place for Phase 2 API
</success_criteria>

<output>
After completion, create `.planning/phases/02-code-generation/02-01-SUMMARY.md`
</output>
